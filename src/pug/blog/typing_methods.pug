extends _blog.pug

block append subtitle
  | Typing methods

block content
  h2 Typing methods
  hr
  p
    i 22 March 2023 <br>
  hr

  h3 1. Introduction
  p When using a videogame controller (or any device which is not a keyboard) on a computer or videogame console, sometimes it is necessary to input alphanumeric characters for different purposes, such as:
  ul
    li Search box in a game list.
    li Search box in an internet browser.
    li Login credentials (user and password).
    li Basic chat communication.
  p These are usually solved by some kind of #[em on-screen keyboard] #[i (Fig. A)], but these come with their own limitations, they require a tight OS integration (as they do on videogame consoles) or otherwise these virtual keyboards may not be usable on credential screens, or while playing videogames with exclusive fullscreen.
  p At Input Labs, we developed the Alpakka firmware with the design philosophy of not requiring additional software or drivers, other than the standard keyboard, mouse and gamepad drivers already present on your operating system. And we want to keep exploring that path for developing a generalist method to type on a controller.
  p
    +figure(
      'A',
      'Windows on-screen keyboard',
      '/static/blog/win_keyboard.jpg',
      'small'
    )

  hr

  h3 2. Characteristics

  h4 2.1. Mapping
  p Since a controller has significantly less buttons than a keyboard, we have to find alternative ways to map characters into these limited buttons or analog control surfaces. Methods to do such mapping include:
  ul
    li Grouping several characters, for example #[em A], #[em B], #[em C] into the physical button or selectable, then selecting one of these characters by:
    ul
      li Pressing the button repeatedly during a fixed amount of time to cycle through the characters, as #[+ax('https://en.wikipedia.org/wiki/Feature_phone') feature phones] #[i (fig. B)] common method for writing SMS messages in the 2000s.
      li Using simultaneously a button or control surface to preselect a character group, then using another button or control surface to cycle or select the final character. As for example in the Steam Controller #[em Daisywheel] #[i (fig. C)].
    li Using the analog surfaces to allow input in which each character is clearly distinguishable, as for example character recognition.
  +figure(
    'B',
    'Nokia 3210 keypad (1999)',
    '/static/blog/keypad.jpg',
    'small inline'
  )
  +figure(
    'C',
    'Steam Controller Daisywheel (2015)',
    '/static/blog/daisywheel.jpg',
    'small inline'
  )


  h4 2.2. Operating system integration and visual feedback
  p Since we do not want to rely on OS integration (so no #[em on-screen keyboard]), we need a solution that allows the user to input any of the 40+ arbitrary alphanumeric and additional symbols with minimal visual feedback.
  p One of the potential solutions we tried is to apply the same concept of #[em preview and commit] characters that was used in #[em feature phones], in which a single button or action is used for cycling between several characters, and only later the character is "committed".
  +figure(
    'D',
    'Character preview and commit',
    '/static/blog/sms.gif',
    'small'
  )
  p This same concept can be used in PC by sending (and deleting) characters on demand, improving the discoverability of the mapping, and making the learning curve swallower. Unfortunately it is #[em not compatible with 100% of the usecases], as for example it may be problematic:
  ul
    li If a searchbox is auto-completing what is written on it and "auto-committing" characters.
    li If searchbox suggestions rendering is making the system to lag a bit.
    li If the input is obscured as in a password field.
    li If the UI is expecting a simple key press (binding menu).

  h4 2.3. Learning cycle
  p On a physical or virtual keyboard, discovery is as straight forward as looking for the character you want on the keyboard, but discovery on a controller is not so easy. The limited number of buttons on a controller and the requirement for a mapping solution (explained above) means that the user will be required to learn and memorize how the mapping works, in a cycle like:
  pre: code.
      ///
       │
       ▼
    ┌──────────────────────────────────────────┐
    │User knows how to type the next character?│
    └──┬─────────────────────────────────┬─────┘
       │                                 │
       │YES                              │NO
       │                                 │
       ▼                                 ▼
    ┌────────────────────┐      ┌──────────────────┐
    │User typed the      │◄─────┤User utilizes a   │
    │character correctly?│      │discovery resource│
    └──┬───────┬─────────┘      │to learn how      │
       │       │     ▲          └──────────────────┘
       │YES    │NO   │                   :
       │       │     │                   :
       │       ▼     │                   ▼
       │   ┌─────────┴────┐        ┌───────────┐
       │   │User deletes  │        │Reinforced │
       │   │last character│ - - - ►│learning   │
       ▼   └──────────────┘        └───────────┘
      ///

  p Discovery methods may include using the character preview as defined above, or just trying several buttons and checking their output, or in the worst case looking into the manual or reference.
  p Ideally when the user does not remember or fails to input the character, the process of recovery and discovery should facilitate the learning, as in the next time the user wants to type the same character there are more chances they remember. Different mapping methods and grouping logics do have an impact on how effectively these are remembered, but the results will vary person by person.
  p At the same time it is expected that the user is able to recover easily from mistakes, as for example the #[em delete / backspace] key should always be consistently accessible on the same button.

  h4 2.4. Manipulation complexity
  p Physical keyboards are designed to have a very small entry barrier, the user can operate them with a single finger if necessary, at any speed the user feel comfortable. So ideally we want to aim for similar requirements:
  ul
    li Avoid using solutions that rely on timing between button presses.
    li Avoid requiring very accurate movement in analog controls (thumbstick, gyro).
    li Avoid simultaneous input in which the user is required do perform actions with multiple fingers at once, specially if one or more of the actions involve analog input.

  h4 2.5. Speed
  p Despite typing speed not being a priority goal for the solution we are looking for, the higher the theoretical words-per-minute an input method could reach, the better it could act as a generalist typing method.

  h4 2.6. Cross-device compatibility
  p Ideally the solution should be complatible with both #[+a('/alpakka') Alpakka] and #[+a('/kapybara') Kapybara] devices, as well as any other controller with similar characteristics (e.g. Xbox controller or DualShock) so everyone benefits from the research, tester's feedback, and development iterations we achieve.

  hr
  h3 3. Input methods (early evaluation)
  p We evaluated a total of #[em 9 potential typing methods], and we created early implementations for 7.
  //- p All of these were conceived to be integrated as part of the Alpakka #[+a('/alpakka/manual/profile_desktop') Desktop profile].
  p This is a high level view of the characteristics, advantages and disadvantages we found on each of these methods:

  table.manual.hdiv.col4
    tr
      td
      th Controls & grouping
      th Notes

    tr
      th
        div Daisywheel
        div.subtitle Implemented and ready for beta
      td
        div #[b Primary:] Thumbstick direction.
        div &nbsp;
        div #[b Secondary:] ABXY.
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div ----  ABCD  EFGH
          div IJKL  ----  OMN-
          div PQRS  TUV-  WXYZ
      td
        ul
          li No preview.
          li Inspired by Steam Controller implementation.
          li Keypad-style grouping.
          li Vowels on cardinal directions.
          li Optimized for letter frequency (english).

    tr
      th
        div Analog keypad, 3 variants
        div.subtitle Implemented in alpha, rejected
      td
        div #[b Primary:] Thumbstick direction.
        div &nbsp;
        div #[b Secondary:] Thumbstick radius (cycle next on outer ring, commit when back to center).
        div &nbsp;
        div #[b Secondary alt:] Mousewheel (cycle next or prev, commit when TS back to center).
        div &nbsp;
        div #[b Secondary alt:] Thumbstick dial cycling (cycle by turning around thumbstick clockwise or anticlockwise, 90° each cycle, commit when back to center).
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div ----  ABCD  EFGH
          div IJKL  ----  OMN-
          div PQRS  TUV-  WXYZ
      td
        ul
          li Preview is optional.
          li Keypad-style grouping.
          li Vowels on cardinal directions.
          li Optimized for letter frequency (english).
          li Hard to perform due to accurate or simultaneous input required.
          li Thumbstick dialing later evolved into #[em glyph-stick] method.

    tr
      th
        div Clover keyboard
        div.subtitle Implemented in alpha, rejected
      td
        div #[b Primary:] ABXY.
        div &nbsp;
        div #[b Secondary:] Thumbstick direction (and push).
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div (X)  (A)  (B)  (Y)
          div QWE  RTY  UIO  P
          div ASD  FGH  JKL  ;
          div ZXC  VBN  M,.  /
      td
        ul
          li No preview.
          li Grouped as querty keyboard sections.
          li Named as tribute to Daisywheel.
          li Very hard to discover and remember mapping.

    tr
      th
        div Qwerty rows
        div.subtitle Only concept, never implemented
      td
        div #[b Primary:] L4 and R4.
        div &nbsp;
        div #[b Secondary:] Dpad, Select, ABXY.
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div (L4): &nbsp;&nbsp; QWERTYUIO
          div (R4): &nbsp;&nbsp; ASDFGHJKL
          div (L4+R4): ZXCVBNMP
      td
        ul
          li No preview.
          li Grouped as querty keyboard rows.
          li Possibly very hard to discover and remember mapping.
          li It requires using at least 4 fingers.
          li Too many buttons required to use in single-hand devices.

    tr
      th
        div Glyph-stick
        div.subtitle Implemented and ready for beta
      td
        div #[b Primary:] Thumbstick (glyph evaluated when stick is back to center).
        div &nbsp;
        div: i (No grouping, see glyph table below)
      td
        ul
          li No preview.
          li Glyphs resemble actual character glyphs.
          li Glyphs are optimized so more frequent characters use shorter glyphs if possible.
          li All glyphs start and end into a cardinal direction.

    tr
      th
        div Gyro projected keyboard
        div.subtitle Implemented in alpha, rejected
      td
        div #[b Primary:] L1 (Starts projection from the center, commits when released).
        div &nbsp;
        div #[b Secondary:] Gyro (Moves the virtual cursor within the projection boundaries).
        div &nbsp;
        div: i (No grouping)
      td
        ul
          li Preview is required.
          li Like the Playstation 4 on-screen gyro keyboard, but without the on-screen keyboard.
          li Requires to remember querty keyboard layout quite well.
          li There is no way to know how close to switch character the virtual cursor is.

    tr
      th
        div Gyro character recognition
        div.subtitle Only concept, never implemented
      td
        div #[b Primary:] L1 (Starts character recognition, try to match character on release).
        div &nbsp;
        div #[b Secondary:] Gyro (Moves the virtual "pen").
        div &nbsp;
        div: i (No grouping)
      td
        ul
          li No preview.
          li As in writing on the air.
          li Firmware implementation would be very hard to develop.
          li Would require to adapt to user's specific way to write characters?.

  hr
  h3 4. Input methods (further evaluation)
  p From all the methods evaluated, we decided to do further testing with 2 of them: #[em Daisywheel] and #[em Glyph-stick]. These will be part of the next Alpakka firmware #[+ax(org.fw_releases) Beta release] (too be announced later), with the goal of getting feedback from testers, iterate over the implementations, and/or discard the methods completely.

  h4 4.1. Daisywheel
  ul
    li Based on Steam Controller / Steam Input daisywheel method.
    li Will be available on the #[+a('/alpakka/manual/profile_desktop') Desktop profile].
    li The #[em thumbstick] direction pre-selects a group of 4 characters, final selection is made with #[em ABXY] buttons.
    li Classic variant:
    ul
      li Alphabetical grouping, same than the original daisywheel.
      li Order of face buttons is #[em X], #[em Y], #[em B], #[em A].
    li Tweaked variant:
    ul
      li Keypad-style grouping, but adapted for having no center key.
      li Order of face buttons is #[em A], #[em B], #[em X], #[em Y].
      li #[em O] and #[em U] order is tweaked so all vowels are located on the #[em A button].
      li #[em X] and #[em Y] order is tweaked so they are located on the #[em X button] and #[em Y button].

  +figure(
    null,
    'Daisywheel (classic) - Steam Controller variant',
    '/static/blog/daisywheel_classic.png',
    'big inline'
  )
  +figure(
    null,
    'Daisywheel (tweaked) - Input Labs variant',
    '/static/blog/daisywheel_tweaked.png',
    'big inline'
  )

  h4 4.2. Glyph-stick
  p Miau

  hr
  h3 5. Feedback received and conclusions
  p -


  hr
  p Thanks a lot for the support! <br> - M&M <3



